<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tuku Group - Independent Creative House | Thoughtful Brands Built with Intention</title>
    <meta name="description" content="Tuku Group is an independent creative house for ventures that matter. We make real what we believe in and work alongside brands that share our ethos of craft over noise.">
    <meta name="keywords" content="creative house, independent brands, thoughtful brands, intentional design, craft over noise, brand guidance, creative ventures">
    <meta name="author" content="Tuku Group">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="https://tukugroup.com/">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://tukugroup.com/">
    <meta property="og:title" content="Tuku Group - Independent Creative House">
    <meta property="og:description" content="A creative house for ventures that matter. We make real what we believe in and work alongside brands that share our ethos.">
    <meta property="og:image" content="https://tukugroup.com/images/tuku-group-og.png">
    <meta property="og:site_name" content="Tuku Group">
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://tukugroup.com/">
    <meta property="twitter:title" content="Tuku Group - Independent Creative House">
    <meta property="twitter:description" content="A creative house for ventures that matter. We make real what we believe in and work alongside brands that share our ethos.">
    <meta property="twitter:image" content="https://tukugroup.com/images/tuku-group-og.png">
    
    <!-- Theme & Performance -->
    <meta name="theme-color" content="#000000">
    <meta name="robots" content="index, follow">
    <link rel="stylesheet" href="css/main.css?v=1.1">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600&display=swap" rel="stylesheet">
    
    <!-- Structured Data -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@graph": [
        {
          "@type": "Organization",
          "@id": "https://tukugroup.com/#organization",
          "name": "Tuku Group, LLC",
          "alternateName": "Tuku Group",
          "url": "https://tukugroup.com/",
          "logo": "https://tukugroup.com/images/tuku-group-logo.png",
          "description": "Independent creative house for ventures that matter. We make real what we believe in and work alongside brands that share our ethos.",
          "foundingDate": "2025",
          "legalName": "Tuku Group, LLC",
          "organizationType": "Corporation",
          "contactPoint": {
            "@type": "ContactPoint",
            "email": "contact@tukugroup.com",
            "contactType": "business inquiry"
          },
          "owns": [
            {
              "@type": "Organization",
              "@id": "https://vibekween.github.io/of-the-culture-landing/#organization",
              "name": "OF THE CULTURE"
            }
          ]
        },
        {
          "@type": "WebSite",
          "@id": "https://tukugroup.com/#website",
          "url": "https://tukugroup.com/",
          "name": "Tuku Group",
          "description": "Independent ideas. Thoughtful brands. Built with intention.",
          "publisher": {
            "@id": "https://tukugroup.com/#organization"
          },
          "inLanguage": "en-US"
        },
        {
          "@type": "WebPage",
          "@id": "https://tukugroup.com/#webpage",
          "url": "https://tukugroup.com/",
          "name": "Tuku Group - Independent Creative House",
          "isPartOf": {
            "@id": "https://tukugroup.com/#website"
          },
          "about": {
            "@id": "https://tukugroup.com/#organization"
          },
          "description": "A creative house for ventures that matter. Craft over noise. Culture as compass. Independent by choice.",
          "inLanguage": "en-US"
        }
      ]
    }
    </script>
</head>
<body>
    <!-- Cloud Background Component -->
    <div class="cloud-background">
        <canvas id="cloudCanvas"></canvas>
    </div>

    <!-- Main Content Layer -->
    <main class="page">
        
        <section class="block">
            <h1>TUKU GROUP</h1>
        </section>

        <section class="block">
            <h2 class="visually-hidden">Company Mission</h2>
            <p>Independent ideas.<br>Thoughtful brands.<br>Assembled with intention.</p>
        </section>

        <section class="block">
            <p>A creative house for ventures that matter.</p>
        </section>

        <section class="block">
            <p>We make real what we believe in and guide brands that share our ethos.</p>
        </section>

        <section class="block">
            <h2 class="visually-hidden">Core Philosophy</h2>
            <p><span class="philosophy-header">Craft over noise.</span><br>Fewer, better, slower.</p>
        </section>

        <section class="block">
            <p><span class="philosophy-header">Culture as compass.</span><br>Present-tense <a href="signals/" class="signals-link">SIGNALS</a>, designed to inform.</p>
        </section>

        <section class="block">
            <p><span class="philosophy-header">Independent by choice.</span><br>Decentralized thinking, sovereign in approach.</p>
        </section>

        <section class="block">
            <p>We selectively work alongside emerging labels, helping clarify vision, refine execution, and create resonance.</p>
        </section>

        <section class="block">
            <p>A conversation, then a plan.</p>
        </section>

        <section class="block">
            <p>If the fit is right, we scope something small and ship it well.</p>
        </section>

        <section class="block">
            <a href="mailto:contact@tukugroup.com?subject=Start%20a%20conversation%20—%20Tuku%20Group">contact@tukugroup.com</a>
        </section>


        <section class="block">
            <div class="split-flap-container">
                <div class="split-flap-status">
                    <span class="status-text">PROJECTS IN PROGRESS</span>
                </div>
                <div class="split-flap-display" id="splitFlapDisplay"></div>
            </div>
        </section>

        <section class="block footer">
            <p>© 2025 Tuku Group, LLC.<br>Independent and privately held.</p>
        </section>

    </main>

    <style>
        .split-flap-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .split-flap-status {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .status-light {
            width: 12px;
            height: 12px;
            background-color: #00ff00;
            border-radius: 50%;
            animation: blink 1.5s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        .status-text {
            font-size: 0.625rem;
            font-weight: 500;
            letter-spacing: 0.1em;
        }

        .split-flap-display {
            display: flex;
            gap: 2px;
            justify-content: center;
        }

        .flap-char {
            width: 18px;
            height: 27px;
            border: 1px solid #ddd;
            background-color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 500;
            overflow: hidden;
            position: relative;
        }

        .flap-char-inner {
            transition: transform 60ms ease-in-out;
        }

        @media (max-width: 1023px) {
            .flap-char {
                width: 16px;
                height: 25px;
                font-size: 10px;
            }
        }

        @media (max-width: 767px) {
            .flap-char {
                width: 13px;
                height: 22px;
                font-size: 9px;
            }
        }

        @media (max-width: 479px) {
            .flap-char {
                width: 11px;
                height: 18px;
                font-size: 7px;
            }
        }
    </style>

    <script>
        // Cloud Background Component Configuration
        const cloudConfig = {
            cloudCount: 8,
            lineWidth: 1.8,
            cloudColor: '#7a152e',
            complexity: 2,
            density: 0.6 // Controls cloud distribution density
        };

        class CloudBackgroundComponent {
            constructor(config) {
                this.canvas = document.getElementById('cloudCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.config = config;
                
                this.setupCanvas();
                this.generate();
                
                // Debounced resize handler for performance
                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        this.setupCanvas();
                        this.generate();
                    }, 250);
                });
                
                // Mobile orientation change handler
                window.addEventListener('orientationchange', () => {
                    setTimeout(() => {
                        this.setupCanvas();
                        this.generate();
                    }, 300);
                });
            }
            
            setupCanvas() {
                // Match exact viewport dimensions - no overflow
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                
                // Set canvas style dimensions for proper scaling
                this.canvas.style.width = window.innerWidth + 'px';
                this.canvas.style.height = window.innerHeight + 'px';
                
                // Handle high DPI displays
                const dpr = window.devicePixelRatio || 1;
                this.canvas.width = window.innerWidth * dpr;
                this.canvas.height = window.innerHeight * dpr;
                this.ctx.scale(dpr, dpr);
            }
            
            random() { return Math.random(); }
            
            organicPoint(x, y, variation = 10) {
                return {
                    x: x + (this.random() - 0.5) * variation,
                    y: y + (this.random() - 0.5) * variation
                };
            }
            
            
            drawWisp(centerX, centerY, scale, offset) {
                const ctx = this.ctx;
                
                // Restore original proportions for natural cloud shapes
                const width = (80 + this.random() * 120) * scale;
                const height = (40 + this.random() * 60) * scale;
                const segments = 5 + Math.floor(this.random() * 4);
                
                const xOffset = (offset - 0.5) * width * 0.4;
                const yOffset = (this.random() - 0.5) * height * 0.4;
                
                ctx.beginPath();
                
                const points = [];
                for (let i = 0; i <= segments; i++) {
                    const angle = (i / segments) * Math.PI * 2;
                    const radiusVar = 0.7 + this.random() * 0.5;
                    const x = centerX + xOffset + Math.cos(angle) * width * radiusVar;
                    const y = centerY + yOffset + Math.sin(angle) * height * radiusVar;
                    points.push(this.organicPoint(x, y, 12 * scale));
                }
                
                ctx.moveTo(points[0].x, points[0].y);
                
                for (let i = 0; i < points.length - 1; i++) {
                    const p1 = points[i];
                    const p2 = points[i + 1];
                    const cp1 = this.organicPoint(
                        p1.x + (p2.x - p1.x) * 0.5,
                        p1.y,
                        18 * scale
                    );
                    const cp2 = this.organicPoint(
                        p1.x + (p2.x - p1.x) * 0.5,
                        p2.y,
                        18 * scale
                    );
                    
                    ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, p2.x, p2.y);
                }
                
                ctx.stroke();
                
                // Internal details
                if (this.random() > 0.4 && this.config.complexity > 1) {
                    ctx.globalAlpha *= 0.5;
                    ctx.lineWidth = this.config.lineWidth * 0.6;
                    
                    const innerLines = 1 + Math.floor(this.random() * 2);
                    for (let l = 0; l < innerLines; l++) {
                        const inset = 0.3 + this.random() * 0.4;
                        ctx.beginPath();
                        
                        const startAngle = this.random() * Math.PI * 2;
                        const endAngle = startAngle + Math.PI * (0.4 + this.random() * 0.6);
                        
                        const sx = centerX + xOffset + Math.cos(startAngle) * width * inset;
                        const sy = centerY + yOffset + Math.sin(startAngle) * height * inset;
                        const sp = this.organicPoint(sx, sy, 10 * scale);
                        
                        ctx.moveTo(sp.x, sp.y);
                        
                        const mx = centerX + xOffset + Math.cos((startAngle + endAngle) / 2) * width * (inset + 0.1);
                        const my = centerY + yOffset + Math.sin((startAngle + endAngle) / 2) * height * (inset + 0.1);
                        const mp = this.organicPoint(mx, my, 10 * scale);
                        
                        const ex = centerX + xOffset + Math.cos(endAngle) * width * inset;
                        const ey = centerY + yOffset + Math.sin(endAngle) * height * inset;
                        const ep = this.organicPoint(ex, ey, 10 * scale);
                        
                        ctx.quadraticCurveTo(mp.x, mp.y, ep.x, ep.y);
                        ctx.stroke();
                    }
                }
            }
            
            generate() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                const clouds = [];
                const isMobile = window.innerWidth <= 768;
                
                // Adjust cloud count for mobile
                let cloudCount = Math.ceil(this.config.cloudCount * this.config.density);
                if (isMobile) {
                    cloudCount = Math.max(3, Math.floor(cloudCount * 0.6)); // Fewer clouds on mobile
                }
                
                for (let i = 0; i < cloudCount; i++) {
                    // Get position that avoids content areas
                    const position = this.getPositionAvoidingContent();
                    
                    // Scale clouds appropriately for mobile
                    let scale;
                    if (isMobile) {
                        scale = 0.3 + this.random() * 0.4; // Smaller clouds on mobile
                    } else {
                        scale = 0.4 + this.random() * 0.6;
                    }
                    
                    // Calculate base opacity based on viewport position
                    let opacity = this.calculateOpacity(position.y);
                    
                    // Reduce opacity if cloud is in text area
                    if (this.isInTextArea(position.x, position.y)) {
                        opacity *= 0.4; // Make 60% transparent behind text (40% of normal)
                    }
                    
                    clouds.push({ x: position.x, y: position.y, scale, opacity });
                }
                
                clouds.forEach(cloud => {
                    this.drawCloudWithOpacity(cloud.x, cloud.y, cloud.scale, cloud.opacity);
                });
            }
            
            getPositionAvoidingContent() {
                // Use actual viewport dimensions (not canvas dimensions)
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                const isMobile = viewportWidth <= 768;
                
                // Define header height based on viewport size
                let headerHeight;
                if (isMobile) {
                    // Mobile: more conservative header space
                    headerHeight = Math.min(250, viewportHeight * 0.35);
                } else {
                    // Desktop: larger header space  
                    headerHeight = Math.min(400, viewportHeight * 0.45);
                }
                
                // Account for maximum cloud size to prevent cutoffs
                const maxCloudWidth = isMobile ? 120 : 200; // Estimated max cloud width
                const maxCloudHeight = isMobile ? 80 : 120; // Estimated max cloud height
                
                // Safe margins accounting for cloud dimensions
                const horizontalMargin = Math.max(20, maxCloudWidth / 2);
                const verticalMargin = Math.max(20, maxCloudHeight / 2);
                
                // Generate position within safe bounds that prevent any cutoffs
                const x = horizontalMargin + (this.random() * (viewportWidth - (horizontalMargin * 2)));
                const y = verticalMargin + (this.random() * (headerHeight - verticalMargin * 2));
                
                return { x, y };
            }
            
            isInTextArea(x, y) {
                // Define text areas based on typical content layout
                const viewportWidth = window.innerWidth;
                const contentWidth = Math.min(600, viewportWidth - 40);
                const contentLeft = (viewportWidth - contentWidth) / 2;
                const contentRight = contentLeft + contentWidth;
                const isMobile = viewportWidth <= 768;
                
                // Text area boundaries
                const textAreas = [
                    // TUKU GROUP title area
                    {
                        left: contentLeft - 50,
                        right: contentRight + 50,
                        top: isMobile ? 40 : 60,
                        bottom: isMobile ? 120 : 150
                    },
                    // Three-line manifesto area
                    {
                        left: contentLeft - 30,
                        right: contentRight + 30,
                        top: isMobile ? 140 : 180,
                        bottom: isMobile ? 240 : 300
                    }
                ];
                
                // Check if cloud position overlaps any text area
                return textAreas.some(area => 
                    x >= area.left && x <= area.right && 
                    y >= area.top && y <= area.bottom
                );
            }
            
            weightedRandomY() {
                // Weight distribution toward top 60% of viewport
                const bias = Math.pow(this.random(), 1.5);
                return bias * this.canvas.height;
            }
            
            calculateOpacity(y) {
                const viewportHeight = window.innerHeight;
                
                if (y < viewportHeight * 0.4) {
                    return 0.8 + this.random() * 0.2; // Strong opacity in header area
                } else if (y < viewportHeight * 0.7) {
                    return 0.4 + this.random() * 0.3; // Medium opacity in content area
                } else {
                    const fadeProgress = (y - viewportHeight * 0.7) / (viewportHeight * 0.3);
                    return Math.max(0.05, 0.4 * (1 - fadeProgress)); // Fade out at bottom
                }
            }
            
            drawCloudWithOpacity(startX, startY, scale, baseOpacity) {
                const ctx = this.ctx;
                const lw = this.config.lineWidth;
                
                ctx.strokeStyle = this.config.cloudColor;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                const wisps = 2 + this.config.complexity;
                const layers = 1 + Math.floor(this.config.complexity / 2);
                
                for (let layer = 0; layer < layers; layer++) {
                    const layerOpacity = (0.7 - (layer * 0.2)) * baseOpacity;
                    ctx.globalAlpha = layerOpacity;
                    ctx.lineWidth = lw * (1 - layer * 0.2);
                    
                    for (let w = 0; w < wisps; w++) {
                        this.drawWisp(startX, startY, scale, w / wisps);
                    }
                }
                
                ctx.globalAlpha = 1.0;
            }
        }

        // Initialize Cloud Background Component
        document.addEventListener('DOMContentLoaded', () => {
            new CloudBackgroundComponent(cloudConfig);
        });

        class SplitFlapDisplay {
            constructor(containerId) {
                this.container = document.getElementById(containerId);
                this.phrases = [
                    "OF THE CULTURE",
                    "FIELDBOTZ",
                    "ISLE OF VERT PUBLISHING",
                    "PLAIN VANILLE",
                    "[REDACTED]"
                ];
                this.currentPhraseIndex = 0;
                this.maxLength = Math.max(...this.phrases.map(phrase => phrase.length));
                this.characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
                this.isAnimating = false;
                
                this.init();
                this.startCycle();
            }

            init() {
                this.container.innerHTML = '';
                for (let i = 0; i < this.maxLength; i++) {
                    const charSlot = document.createElement('div');
                    charSlot.className = 'flap-char';
                    charSlot.innerHTML = '<div class="flap-char-inner"> </div>';
                    this.container.appendChild(charSlot);
                }
                this.charSlots = this.container.querySelectorAll('.flap-char');
            }

            async animateToPhrase(phrase) {
                if (this.isAnimating) return;
                this.isAnimating = true;
                
                const paddedPhrase = phrase.padEnd(this.maxLength, ' ');
                const currentText = Array.from(this.charSlots).map(slot => 
                    slot.querySelector('.flap-char-inner').textContent
                );

                const clearingPositions = [];
                for (let i = phrase.length; i < this.maxLength; i++) {
                    if (currentText[i] && currentText[i] !== ' ') {
                        clearingPositions.push(i);
                    }
                }

                await new Promise(resolve => setTimeout(resolve, 100));

                if (clearingPositions.length > 0) {
                    const clearPromises = clearingPositions.map(async (pos, idx) => {
                        await new Promise(resolve => setTimeout(resolve, idx * 15));
                        await this.animateCharacter(pos, ' ', currentText[pos], 'clear');
                    });
                    await Promise.all(clearPromises);
                    await new Promise(resolve => setTimeout(resolve, 40));
                }

                for (let i = 0; i < phrase.length; i++) {
                    const targetChar = paddedPhrase[i];
                    const currentChar = this.charSlots[i].querySelector('.flap-char-inner').textContent;
                    
                    if (targetChar !== currentChar) {
                        await this.animateCharacter(i, targetChar, currentChar, 'normal');
                    }
                    
                    const delay = targetChar === ' ' ? 20 : 45;
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
                
                this.isAnimating = false;
            }

            async animateCharacter(index, targetChar, currentChar, animationType = 'normal') {
                const charSlot = this.charSlots[index];
                const charInner = charSlot.querySelector('.flap-char-inner');
                
                let cycles, speed;
                
                if (animationType === 'clear') {
                    cycles = 3;
                    speed = 35;
                } else if (targetChar === ' ') {
                    cycles = 1;
                    speed = 18;
                } else if (currentChar === ' ') {
                    cycles = 5;
                    speed = 65;
                } else {
                    cycles = 6;
                    speed = 70;
                }

                for (let cycle = 0; cycle < cycles; cycle++) {
                    const randomChar = this.characters[Math.floor(Math.random() * this.characters.length)];
                    charInner.textContent = randomChar;
                    
                    const variance = Math.random() * 10 - 5;
                    await new Promise(resolve => setTimeout(resolve, speed + variance));
                }

                charInner.textContent = targetChar;
                await new Promise(resolve => setTimeout(resolve, 10));
            }

            startCycle() {
                const animateNext = async () => {
                    const phrase = this.phrases[this.currentPhraseIndex];
                    await this.animateToPhrase(phrase);
                    
                    this.currentPhraseIndex = (this.currentPhraseIndex + 1) % this.phrases.length;
                    setTimeout(animateNext, 4000);
                };

                animateNext();
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            new SplitFlapDisplay('splitFlapDisplay');
        });
    </script>
</body>
</html>